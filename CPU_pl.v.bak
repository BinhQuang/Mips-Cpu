module CPU_pl (
    input  clk,
    input  rst,
    output  aluZero,
    output [31:0] instr,
    output [31:0] pc,
    output [31:0] pcNext,
    output [31:0] aluResult
);

    // Internal signals
    wire [31:0] pc_new, pcBranch, pc_Branch;
    wire [31:0] signImm;
    wire BranchCond;
    wire [4:0] a3;
    wire [31:0] wd3, rd1, rd2, srcA, srcB;
    wire [31:0] dmRData, dmWData, dmAddr;
    wire [5:0] imAddr;

    // Pipeline registers
    reg [31:0] IF_ID_pcNext, IF_ID_instr;
    reg [31:0] ID_EX_rd1, ID_EX_rd2, ID_EX_signImm;
    reg [3:0]  ID_EX_ALUOp;
    reg [1:0]  ID_EX_regDst, ID_EX_memToReg;
    reg        ID_EX_aluSrc, ID_EX_regWrite, ID_EX_memWrite, ID_EX_Branch, ID_EX_condZero;
    reg [4:0]  ID_EX_a3;
    reg [31:0] EX_MEM_aluResult;
    reg        EX_MEM_memWrite;
    reg [31:0] EX_MEM_rd2;
    reg [1:0]  EX_MEM_memToReg;
    reg        EX_MEM_regWrite;
    reg [4:0]  EX_MEM_a3;
    reg [31:0] MEM_WB_aluResult, MEM_WB_dmRData;
    reg [1:0]  MEM_WB_memToReg;
    reg        MEM_WB_regWrite;
    reg [4:0]  MEM_WB_a3;

    // Hazard detection signals
    wire stall;
    wire [1:0] forwardA, forwardB;
    wire lwStall;

    // Control signals
    wire [5:0] opcode;
    wire [5:0] funct;
    reg [3:0] ALUOp;
    reg [1:0] pcSrc, regDst, memToReg;
    reg aluSrc, regWrite, memWrite, Branch, condZero;

    // ======================
    // 1. PC Register (IF)
    // ======================
    register r_pc (
        .clk(clk),
        .rst(rst),
        .d(pc_new),
        .q(pc)
    );
    assign imAddr = pc >> 2;
    assign pcNext = pc + 32'd4;

    // Instruction Memory (IF)
    rom instr_rom (
        .imAddr(imAddr),
        .imData(instr)
    );

    // Pipeline IF/ID with stall
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            IF_ID_pcNext <= 0;
            IF_ID_instr <= 0;
        end else if (~stall) begin
            IF_ID_pcNext <= pcNext;
            IF_ID_instr <= instr;
        end else begin
            IF_ID_instr <= 0; // NOP for stall
        end
    end

    // ======================
    // 2. Instruction Decode (ID)
    // ======================
    assign opcode = IF_ID_instr[31:26];
    assign funct  = IF_ID_instr[5:0];
    assign signImm = {{16{IF_ID_instr[15]}}, IF_ID_instr[15:0]};

    // Control Unit (ID)
    always @(*) begin
        regDst = 2'b00;
        regWrite = 0;
        Branch = 0;
        condZero = 0;
        aluSrc = 0;
        memWrite = 0;
        memToReg = 2'b00;
        pcSrc = 2'b00;
        ALUOp = 4'b0101;

        case (opcode)
            6'b000000: begin // R-type
                regDst = 2'b01;
                regWrite = 1;
                aluSrc = 0;
                case (funct)
                    6'b100001: ALUOp = 4'b0101; // addu
                    6'b100011: ALUOp = 4'b0110; // subu
                    6'b100100: ALUOp = 4'b0001; // and
                    6'b100101: ALUOp = 4'b0011; // or
                    6'b100110: ALUOp = 4'b0010; // xor
                    6'b101011: ALUOp = 4'b1000; // slt
                    6'b000000: ALUOp = 4'b1010; // sll
                    6'b000010: ALUOp = 4'b1011; // srl
                    6'b001000: begin ALUOp = 4'b0110; regWrite = 0; pcSrc = 2'b10; end // jr
                endcase
            end
            6'b000100: begin ALUOp = 4'b0110; Branch = 1; condZero = 1; aluSrc = 0; end // beq
            6'b000101: begin ALUOp = 4'b0110; Branch = 1; condZero = 0; aluSrc = 0; end // bne
            6'b100011: begin ALUOp = 4'b0101; regWrite = 1; aluSrc = 1; memToReg = 2'b01; end // lw
            6'b101011: begin ALUOp = 4'b0101; memWrite = 1; aluSrc = 1; end // sw
            6'b000010: begin ALUOp = 4'b0110; pcSrc = 2'b01; end // j
            6'b000011: begin ALUOp = 4'b0110; regDst = 2'b10; regWrite = 1; pcSrc = 2'b01; memToReg = 2'b10; end // jal
            6'b001001: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b0101; end // addiu
            6'b001000: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b0101; end // addi
            6'b001100: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b0001; end // andi
            6'b001101: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b0011; end // ori
            6'b001011: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b1000; end // sltiu
            6'b001111: begin regDst = 2'b00; regWrite = 1; aluSrc = 1; ALUOp = 4'b1100; end // lui
        endcase
    end

    // Register File (ID)
    assign a3 = (regDst == 2'b01) ? IF_ID_instr[15:11] :
                (regDst == 2'b10) ? 5'b11111 :
                IF_ID_instr[20:16];

    RF rf (
        .clk(clk),
        .a1(IF_ID_instr[25:21]),
        .a2(IF_ID_instr[20:16]),
        .a3(a3),
        .wd3(wd3),
        .we3(regWrite & ~stall), // Disable write during stall
        .rd1(rd1),
        .rd2(rd2)
    );

    // Hazard detection for lw stall
    assign lwStall = (IF_ID_instr[31:26] != 6'b000000) && // Not R-type
                     (IF_ID_instr[31:26] != 6'b000010) && // Not j
                     (IF_ID_instr[31:26] != 6'b000011) && // Not jal
                     (ID_EX_memToReg[1] == 1) && // Previous is lw
                     ((ID_EX_regDst[1] ? 5'b11111 : ID_EX_a3) == IF_ID_instr[25:21] || // rs
                      (ID_EX_regDst[1] ? 5'b11111 : ID_EX_a3) == IF_ID_instr[20:16]); // rt
    assign stall = lwStall;

    // Pipeline ID/EX with stall
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            ID_EX_rd1 <= 0;
            ID_EX_rd2 <= 0;
            ID_EX_signImm <= 0;
            ID_EX_ALUOp <= 0;
            ID_EX_regDst <= 0;
            ID_EX_memToReg <= 0;
            ID_EX_aluSrc <= 0;
            ID_EX_regWrite <= 0;
            ID_EX_memWrite <= 0;
            ID_EX_Branch <= 0;
            ID_EX_condZero <= 0;
            ID_EX_a3 <= 0;
        end else if (~stall) begin
            ID_EX_rd1 <= rd1;
            ID_EX_rd2 <= rd2;
            ID_EX_signImm <= signImm;
            ID_EX_ALUOp <= ALUOp;
            ID_EX_regDst <= regDst;
            ID_EX_memToReg <= memToReg;
            ID_EX_aluSrc <= aluSrc;
            ID_EX_regWrite <= regWrite;
            ID_EX_memWrite <= memWrite;
            ID_EX_Branch <= Branch;
            ID_EX_condZero <= condZero;
            ID_EX_a3 <= a3;
        end
    end

    // ======================
    // 3. Execute (EX)
    // ======================
    // Forwarding logic
    assign srcA = (forwardA == 2'b00) ? ID_EX_rd1 :
                  (forwardA == 2'b01) ? EX_MEM_aluResult :
                  (forwardA == 2'b10) ? MEM_WB_aluResult : ID_EX_rd1;
    assign srcB = (forwardB == 2'b00) ? ID_EX_rd2 :
                  (forwardB == 2'b01) ? EX_MEM_aluResult :
                  (forwardB == 2'b10) ? MEM_WB_aluResult : ID_EX_rd2;

    // Forwarding control
    assign forwardA = (EX_MEM_regWrite && (EX_MEM_a3 != 0) && (EX_MEM_a3 == IF_ID_instr[25:21]) && (ID_EX_a3 != IF_ID_instr[25:21])) ? 2'b01 :
                      (MEM_WB_regWrite && (MEM_WB_a3 != 0) && (MEM_WB_a3 == IF_ID_instr[25:21]) && (EX_MEM_a3 != IF_ID_instr[25:21]) && (ID_EX_a3 != IF_ID_instr[25:21])) ? 2'b10 : 2'b00;
    assign forwardB = (EX_MEM_regWrite && (EX_MEM_a3 != 0) && (EX_MEM_a3 == IF_ID_instr[20:16]) && (ID_EX_a3 != IF_ID_instr[20:16])) ? 2'b01 :
                      (MEM_WB_regWrite && (MEM_WB_a3 != 0) && (MEM_WB_a3 == IF_ID_instr[20:16]) && (EX_MEM_a3 != IF_ID_instr[20:16]) && (ID_EX_a3 != IF_ID_instr[20:16])) ? 2'b10 : 2'b00;

    alu alu_inst (
        .srcA(srcA),
        .srcB((ID_EX_aluSrc == 1) ? ID_EX_signImm : srcB),
        .oper(ID_EX_ALUOp),
        .shift(IF_ID_instr[10:6]),
        .zero(aluZero),
        .result(aluResult)
    );

    assign pcBranch = IF_ID_pcNext + (ID_EX_signImm << 2);
    assign BranchCond = ID_EX_Branch & (aluZero == ID_EX_condZero);
    assign pc_Branch = BranchCond ? pcBranch : IF_ID_pcNext;

    // Pipeline EX/MEM
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            EX_MEM_aluResult <= 0;
            EX_MEM_memWrite <= 0;
            EX_MEM_rd2 <= 0;
            EX_MEM_memToReg <= 0;
            EX_MEM_regWrite <= 0;
            EX_MEM_a3 <= 0;
        end else begin
            EX_MEM_aluResult <= aluResult;
            EX_MEM_memWrite <= ID_EX_memWrite;
            EX_MEM_rd2 <= ID_EX_rd2;
            EX_MEM_memToReg <= ID_EX_memToReg;
            EX_MEM_regWrite <= ID_EX_regWrite;
            EX_MEM_a3 <= ID_EX_a3;
        end
    end

    // ======================
    // 4. Memory Access (MEM)
    // ======================
    assign dmAddr = EX_MEM_aluResult;
    assign dmWData = EX_MEM_rd2;

    ram data_ram (
        .clk(clk),
        .a(dmAddr),
        .we(EX_MEM_memWrite),
        .wd(dmWData),
        .rd(dmRData)
    );

    // Pipeline MEM/WB
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            MEM_WB_aluResult <= 0;
            MEM_WB_dmRData <= 0;
            MEM_WB_memToReg <= 0;
            MEM_WB_regWrite <= 0;
            MEM_WB_a3 <= 0;
        end else begin
            MEM_WB_aluResult <= EX_MEM_aluResult;
            MEM_WB_dmRData <= dmRData;
            MEM_WB_memToReg <= EX_MEM_memToReg;
            MEM_WB_regWrite <= EX_MEM_regWrite;
            MEM_WB_a3 <= EX_MEM_a3;
        end
    end

    // ======================
    // 5. Write-back (WB)
    // ======================
    assign wd3 = (MEM_WB_memToReg == 2'b01) ? MEM_WB_dmRData :
                 (MEM_WB_memToReg == 2'b10) ? IF_ID_pcNext :
                 MEM_WB_aluResult;

    // PC logic (updated for pipeline)
    assign pc_new = (pcSrc == 2'b01) ? {pc[31:28], IF_ID_instr[25:0], 2'b00} :
                    (pcSrc == 2'b10) ? aluResult : pc_Branch;

endmodule